@using Abstractions
@typeparam TPlayer where TPlayer : Player
@typeparam TPiece where TPiece : Piece
@typeparam TGameState where TGameState : GameState<TPlayer, TPiece>

@if (!Visible) return;
@if (State is null) return;

<style>
	.game-grid {
		display: grid;
		grid-template-columns: repeat(@State.Width, 1fr);
		grid-template-rows: repeat(@State.Height, 1fr);
	}

	.game-grid > div {
		border: 1px solid lightgray;
		box-sizing: border-box;
	}
</style>

<div class="game-grid" style="height:100%">
	@for (int y = 1; y <= State.Height; y++)
	{
		for (int x = 1; x <= State.Width; x++)
		{
			<div style="@Style">
				@ChildContent(new Location(x, y))
			</div>
		}
	}
</div>
<p>player name = @PlayerName, current turn = @State?.CurrentPlayer</p>

@code {
	[Parameter] public bool Visible { get; set; } = true;
	[Parameter] public TGameState? State { get; set; }	
	[Parameter] public RenderFragment<Location> ChildContent { get; set; } = (Location location) => @<span>@location.X, @location.Y</span>;

	[Parameter] public string? PlayerName { get; set; }
	[Parameter] public EventCallback<string?> PlayerNameChanged { get; set; }

	private string Style => $"cursor:{(PlayerName == State?.CurrentPlayer ? "pointer" : "not-allowed")}";	
}
